# 924. Minimize Malware Spread
# In a network of nodes, each node i is directly connected 
# to another node j if and only if graph[i][j] = 1.

# Some nodes initial are initially infected by malware.  
# Whenever two nodes are directly connected and at least 
# one of those two nodes is infected by malware, both nodes 
# will be infected by malware.  

# This spread of malware will continue until no more nodes 
# can be infected in this manner.

# Suppose M(initial) is the final number of nodes infected with malware 
# in the entire network, after the spread of malware stops.

# We will remove one node from the initial list.
# Return the node that if removed, would minimize M(initial). 
# If multiple nodes could be removed to minimize M(initial), 
# return such a node with the smallest index.

# Note that if a node was removed from the initial list of infected nodes, 
# it may still be infected later as a result of the malware spread.

# Example 1:

# Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
# Output: 0
# Example 2:

# Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
# Output: 0
# Example 3:

# Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
# Output: 1

# Note:

# 1 < graph.length = graph[0].length <= 300
# 0 <= graph[i][j] == graph[j][i] <= 1
# graph[i][i] = 1
# 1 <= initial.length < graph.length
# 0 <= initial[i] < graph.length

# ALGORITHM:
# This algorithm has a few parts:
# 1. Coloring each component: For each node, if it isn't yet colored, 
#    use a depth-first search to traverse its component, coloring that 
#    component with a new color.
# 2. Size of each color: Count the number of occurrences of each color.
# 3. Find unique colors: Look at the colors of nodes in initial 
#    to see which nodes have unique colors.
# 4. Choose answer: For each node with a unique color, find the size 
#    of that color. The largest size is selected, with ties broken by 
#    lowest node number.
#    a.If there is no node with a unique color, the answer is min(initial).
from collections import Counter

class Solution(object):

    def dfs(self, node, color):
        self.colors[node] = color
        for n, adj in enumerate(self.graph[node]):
            if adj and n not in self.colors:
                self.dfs(n, color) 

    def minMalwareSpread(self, graph, initial):
        self.graph = graph
        self.colors = {}
        color = 0
        num_nodes = len(graph)

        for node in range(num_nodes):
            if node not in self.colors:
                self.dfs(node, color)
                color += 1

        # 2. Size of each color.
        # size[color] = number of occurrences of this color.
        size = Counter(self.colors.values())

        # 3. Find unique colors.
        color_count = Counter()
        for node in initial:
            color_count[self.colors[node]] += 1

        # 4. Answer
        ans = float('inf')
        for x in initial:
            c = self.colors[x]
            if color_count[c] == 1:
                if ans == float('inf'):
                    ans = x
                elif size[c] > size[self.colors[ans]]:
                    ans = x
                elif size[c] == size[self.colors[ans]] and x < ans:
                    ans = x

        return ans if ans < float('inf') else min(initial)    
            